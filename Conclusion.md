# Conclusion of tests

### 1480
建立前N项和数列preSum.

### 724
用到了preSum，此数列可直接将i到j之间某段的数的和，变为`preSum[j] -preSum[i]`的减法运算，尤其在多次使用某段和时，避免用`sum(list[i:j])`,从而减小了空间复杂度.

### 205、290
法1：*哈希表*。进行双射对照（可能需要将string或者list转化为dictionary，采用enumerate函数；带空格的长字符串转化为单词list，需用str.split()函数，返回类型为list）。另，字典的in/not in是针对键而非值。  

法2: zip函数(迭代序列元素打包）。另外，一一对照的情况下，可采用zip函数简化此流程，再结合set类型的不可重复性来去掉重复项。

### 392
法1: 双指针遍历。需用到`for i in list1` 和 `for j in list2`或者`while i < n`，带条件对照遍历。避免嵌套循环，可其中一个list以i=0，满足条件则i+=1的形式迭代。

法2: 暴力算法。需用到，已知值求位置函数，`list.index(value)`，首个出现value的位置。

### 链表问题，常用方法：1）递归；2）设置虚拟头节点；3）快慢指针；4）测试函数（链表和列表之间互相转换）。

### 21
链表问题，链表合并  

两个链表根据值排序合并，需熟悉链表的生成（头节点法（头节点移动），尾节点法（尾节点移动）），要特别注意顺序，如头节点法对于列表为逆序遍历。  

法1: 暴力算法。链表转为列表，合并，排序，再将列表转化为链表。列表和链表互相转换的函数，尤其列表的生成函数，采用头节点法；sort()和reverse()函数在列表内部进行没有返回值。 

法2: 递归函数。由于要递归题目提供的实例构造方法，需使用self.方法(参数)形式。递归函数：1）需要终止条件；2）只关注本层任务；3）返回结果只需关注最终结果。  

### 206
链表问题，反转链表  

法1: 暴力算法，链表转列表，再转链表（可讲列表逆序，也可用头节点法逆序生成列表）

法2: 迭代法，设置辅助节点。每向后移动一位，则反转一位。（当一个节点直线一个新的节点以后，原来的指向会自动消失；容易出现的问题：1）环状，两个节点相互指向成环；2）节点丢失，未能对节点提前赋值，所以要在将链表分为两端之前提前赋值。）  

### 876
#链表问题，寻找中间项  
法1: 暴力算法。法1）链表转换为列表，len()函数判断数量；法2）循环链表找到非空值数量。//运算可实现向下取整。

法2: 双指针法。两个指针，一快一慢，利用步伐差，解决问题。  

### 142, 有环链表  
法1: 双指针法。快慢指针，有环形则会相遇，利用步伐差来确定，本题需要两次相遇。使用while循环语句需注意判断条件。

法2: 暴力算法。节点head可以作为元素（list或者set，但set的效率更高，速度快. 例如，查找效率：set>dict>list），判断新的节点是否已存在set中，存在则返回。

### 121
动态规划问题

此问题直接使用暴力算法会超时。

法1: 暴力二分法，找到最小值，以最小值将list一分为二，后一部分找到pro_1,前一部分继续迭代，结束条件为n_min为0或者1.

法2: 动态规划法，遍历寻找向后最大差值，max_profit = max(price-min_price, max_profit)，min_price = min(price, min_price)，最大利润和最小价格不断记录，不断对比更新。

### 409，最长回文

法1: 暴力算法。先建立字符与相应出现次数的哈希表；再寻找各字符出现次数和最长回文长度之间的关系，偶数直接加，奇数减一以后再加，最后如出现过奇数，则总体加一。

法2: 改进方法。采用collection.Counter()函数，返回counter序列，结合dict()函数，可直接创建出现次数的哈希表。

### 704，二分查找

查找问题

法1： 二分查找法，注意：1）中间节点的选择`middle = (left+right)//2`，防止溢出，2）采用while...else，注意循环的条件 `left <= right`；3）不满足条件的额情况下，最小/最大值需加/减位`left = middle-1`, `right = middle+1`，是不包含中间节点，防止陷入无限循环。

法2: 哈希表。以值为key，位置为 value创建哈希表，再通过哈希表查找。

### 278，判断错误版本

二分查找问题

法1: 二分查找法，相对于一般的二分查找，本例还需结合前一位进行综合判断。

法2: 改进方法。本题特殊点在于值一定存在。仍使用二分查找，但不再以middle为研究对象，由于值一定存在，则`left=right`为最终状态，即为目标节点，最后返回left或者right.本题应防止计算过程中出现溢出(右侧`right = middle`，包含middle项）或者判断条件导致无限循环（`left < right`, `left=middle`时就退出了循环）。

### 202，快乐数

对于需要求余数a%b和整数商a//b时，可用`divmod()`函数一步实现。

本题关键在于判断循环的结束条件。对于结果只有两种情况，happy number: 最终平方和会停留在1；非happy number：最终平方和会陷入一系列数的无限重复循环。

法1: 哈希集合法 哈希表分为哈希映射和哈希集合，哈希集合只函键不含值。利用是否为1为判断条件，出现重复非1的数，则返回false，出现1，则返回true.

法2: 双指针法。快慢指针判断有无环，转化为环形链表问题，无环则为true，有环则为false.

### 54, 螺旋矩阵

矩阵问题

逆向提取序列中的元素，可以使用-1参数，例如对于列表l中，`l[5:1:-1]`是对于位置5到位置2的元素逆序，也可用遍历`for i in range(5,1,-1)`实现。

本题可能需要对list处理的函数，包括`insert()`, `append()`, `pop()`。特别是pop函数，`list.pop()`,一方面函数结果是除去某个位置值以后的列表，另一方面，返回值是删除的值。

法1: 暴力算法。采用递归方法，有外层向内层递归，直到达到终结条件。每一层为顺时针得到新序列，原矩阵需除去相应的部分，以备下一次递归，递归结束条件分为三种情况。

法2: 规律法。实现矩阵的螺旋，规律为：取第一行，剩余的部分选为转置后行再倒序，继续下个循环，直到剩余部分为空。本方法用到了zip函数，该函数生成元素为元组的列表。需了解，“列表 += 元组”，是可行的。

法3: 辅助边界法。设置辅助数，不需要记录已走过的路径。随着路径，边界移动，不断循环，直到某两条边界交错，则跳出循环。

### 1706，球落在何处

法1: 模拟法。模拟行进路径，设置辅助值，以判断位置。  
分析：一方面，考虑小球无法下落的情况（三种：左边界，右边界，V字形），可作为循环条件，所以小球能否下落，下落到那个位置，取决于左右，不取决于上下；  
另一方面，小球下落以后的位置，可用辅助数col判断，初始值为所在列数，从第一行开始，直接加所在行中相应位置的值即可，如向右（+1），向右（-1）。

### 509、70，Fibonacci Number、爬楼梯问题

法1: 暴力递归法，可理解为从大到小不断递归。

法2: 动态规划法，可理解为从小到大，将以算出的数保存，可以选择使用list，或者更简单一些，仅不断记录更新需要使用的两个值，例如：`p,q = q,r`, `r = p+q`.

法3:矩阵快速幂，此方法速度最快。需找到计算矩阵，则只需将初始矩阵与计算矩阵的n次方相乘。此处，矩阵的n次方使用用快速幂法（偶数则计算矩阵平方得到新的计算矩阵，奇数则先提取一个更新后的计算矩阵相乘）。
此方法中，`n&1` 用于判断奇偶性，1为奇，0为偶；`n >>= 1` (即：`n=n>>1`)相当于`n//2`.
